------------Install---------
$ curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh

$ rustc main.rs			# —Å–∫–æ–º–ø–∏–ª–∏—Ä–æ–≤–∞—Ç—å —Ñ–∞–π–ª
$ ./main			# –∑–∞–ø—É—Å—Ç–∏—Ç—å
--------- New Proj--------------
$ cargo new hello_cargo		# project name - hello_cargo
$ cargo build			# —Å–æ–±—Ä–∞—Ç—å –ø—Ä–æ–µ–∫—Ç
$ cargo build --release		# —Å–æ–±—Ä–∞—Ç—å –ø—Ä–æ–µ–∫—Ç –¥–ª—è —Ä–µ–ª–∏–∑–∞ (—Ä–∞–±–æ—Ç–∞–µ—Ç –±—ã—Å—Ç—Ä–µ–µ, —Å–æ–±–∏—Ä–∞–µ—Ç—Å—è –¥–æ–ª—å—à–µ, —Å–æ–±–∏—Ä–∞–µ—Ç –≤ target/release )
$ ./target/debug/hello_cargo	# –∑–∞–ø—É—Å—Ç–∏—Ç—å —Ñ–∞–π–ª
$ cargo run			# —Å–æ–±—Ä–∞—Ç—å –ø—Ä–æ–µ–∫—Ç —Å—Ä–∞–∑—É –∑–∞–ø—É—Å—Ç–∏—Ç—å —Ñ–∞–π–ª (–∞–Ω–∞–ª–æ–≥ cargo build –∏ ./target/debug/hello_cargo)
$ cargo run -p adder		# –∑–∞–ø—É—Å—Ç–∏—Ç—å –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã–π –∫—Ä–µ–π—Ç
$ cargo test
$ RUST_BACKTRACE=1 cargo run	# –∑–∞–ø—É—Å–∫ —Å –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –¥–ª—è —Ç—Ä–∞—Å—Å–∏—Ä–æ–≤–∫–∏ –æ—à–∏–±–æ–∫
$ cargo check			# –±—ã—Å—Ç—Ä–æ –ø—Ä–æ–≤–µ—Ä—è–µ—Ç –≤–∞—à –∫–æ–¥, —á—Ç–æ–±—ã —É–±–µ–¥–∏—Ç—å—Å—è, —á—Ç–æ –æ–Ω –∫–æ–º–ø–∏–ª–∏—Ä—É–µ—Ç—Å—è, –Ω–æ –Ω–µ —Å–æ–∑–¥–∞—ë—Ç –∏—Å–ø–æ–ª–Ω—è–µ–º—ã–π —Ñ–∞–π–ª
---------- Variables-------------
let x = 4; 			# –æ–±—å—è–≤–ª–µ–Ω–∏–µ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π
let mut x = 4;			# –æ–±—å—è–≤–ª–µ–Ω–∏–µ –∏–∑–º–µ–Ω—è–µ–º–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π
let num: u32 = 4;		# –æ–±—å—è–≤–ª–µ–Ω–∏–µ –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –∏ –µ—ë —Ç–∏–ø–∞
const THIS_IS_CONST: u32 = 32;	# –æ–±—å—è–≤–ª–µ–Ω–∏–µ –ø–æ—Å—Ç–æ—è–Ω–Ω–æ–π –ø–µ—Ä–µ–º–µ–Ω–Ω–æ–π –∏ –µ—ë —Ç–∏–ø–∞
–¶–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–π —Ç–∏–ø (integer) 				- u8, u16, u32, u64, u128, usize (u8 –≤–º–µ—â–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –¥–æ 255)
–¶–µ–ª–æ—á–∏—Å–ª–µ–Ω–Ω—ã–π —Ç–∏–ø (integer) —Å–æ –∑–Ω–∞–∫–æ–º( –Ω–∞–ø—Ä–∏–º–µ—Ä "-25") 	- i8, i16, i32, i64, u128, isize (i8 –≤–º–µ—â–∞–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –æ—Ç -128 –¥–æ 127)
–ß–∏—Å–ª–∞ —Å –ø–ª–∞–≤–∞—é—â–µ–π –∑–∞–ø—è—Ç–æ–π				- f32 or f64 (–ø–æ —É–º–æ–ª—á–∞–Ω–∏—é f64), let num: f32 = 2.0;
–õ–æ–≥–∏—á–µ—Å–∫–∏–π —Ç–∏–ø						- bool (true or false) , let truth: bool = false;
–°–∏–º–≤–æ–ª—å–Ω—ã–π —Ç–∏–ø						- char (–æ–¥–∏–Ω–∞—Ä–Ω—ã–µ –∫–∞–≤—ã—á–∫–∏!!!!) , let z: char = 'X'; let heart_eyed_cat = 'üòª';
–ö–æ—Ä—Ç–µ–∂							- let tup: (i32, f64, u8) = (500, 6.4, 1); let tup = (500, 6.4, 1); let (x, y, z) = tup; –¥–æ—Å—Ç—É–ø –ø–æ –∏–Ω–¥–µ–∫—Å—É tup.0
M–∞—Å—Å–∏–≤ array						- let a = [1, 2, 3, 4, 5]; let a: [i32; 5] = [1, 2, 3, 4, 5]; let a = [3; 5]; –¥–æ—Å—Ç—É–ø –ø–æ –∏–Ω–¥–µ–∫—Å—É a[0]; fn func(list: [i32]){--do something--}
---------------Function-----------
fn main() {
    print_labeled_measurement(5, 'h');
}
fn print_labeled_measurement(value: i32, unit_label: char) {
    println!("The measurement is: {value}{unit_label}");
}
fn plus_one(x: i32) -> i32 {
    x + 1
}
---------------Struct---------------
#[derive(Debug)]
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
impl Rectangle {
    fn area2(&self) -> u32 {
        self.widht * self.height
    }
}
-----------Vector-----------------
let v: Vec<i32> = Vec::new();
let v = vec![1, 2, 3,4,5];
let third: &i32 = &v[2];
let third: Option<&i32> = v.get(2);	#–º—ã –ø–æ–ª—É—á–∞–µ–º —Ç–∏–ø Option<&T>
fn main() {
    enum SpreadsheetCell {
        Int(i32),
        Float(f64),
        Text(String),
    }

    let row = vec![
        SpreadsheetCell::Int(3),
        SpreadsheetCell::Text(String::from("blue")),
        SpreadsheetCell::Float(10.12),
    ];
}
v.push(5), pop & etc.
-----------String-----------------
let mut s = String::new();
let data = "initial contents"; let s = data.to_string();
let s = "initial contents".to_string();
let s = String::from("initial contents");
s.push_str("bar");						#–¥–æ–±–∞–≤–ª—è–µ—Ç —Å—Ç—Ä–æ–∫–æ–≤—ã–π —Å—Ä–µ–∑ –∫ s
s.push('l');							#–¥–æ–±–∞–≤–ª—è–µ—Ç —Ç–æ–ª—å–∫–æ –æ–¥–∏–Ω —ç–ª–µ–º–µ–Ω—Ç –∫ s
let s3 = s1 + &s2;						#–æ–±—å–µ–¥–∏–Ω—è–µ—Ç
let s = format!("{s1}-{s2}-{s3}");				#–æ–±—å–µ–¥–∏–Ω—è–µ—Ç
for c in "–ó–¥".chars() {
    println!("{c}");
}								#–¥–æ—Å—Ç—É–ø –∫ —Å–∏–º–≤–æ–ª–∞–º
----------HashMap---------------------
use std::collections::HashMap;
let mut scores = HashMap::new();
scores.insert(String::from("Blue"), 10);
let team_name = String::from("Blue");
let score = scores.get(&team_name).copied().unwrap_or(0);
for (key, value) in &scores {
        println!("{key}: {value}");
    }
scores.entry(String::from("Blue")).or_insert(50);		#–í—Å—Ç–∞–≤–∏—Ç—å 50 , –µ—Å–ª–∏ –Ω–µ—Ç –µ—â–µ –∑–Ω–∞—á–µ–Ω–∏—è, –µ—Å–ª–∏ –µ—Å—Ç—å - –Ω–∏—á–µ–≥–æ –Ω–µ –≤—Å—Ç–∞–≤–ª—è—Ç—å
---------File-----------------------
use std::fs::File;
use std::io::{self, Read};
use std::fs;
fs::read_to_string("hello.txt");				#–æ—Ç–∫—Ä—ã–≤–∞–µ—Ç —Ñ–∞–π–ª, —Å–æ–∑–¥–∞—ë—Ç –Ω–æ–≤—É—é String, —á–∏—Ç–∞–µ—Ç —Å–æ–¥–µ—Ä–∂–∏–º–æ–µ —Ñ–∞–π–ª–∞, —Ä–∞–∑–º–µ—â–∞–µ—Ç –µ–≥–æ –≤ String –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –µ—ë
let greeting_file_result = File::open("hello.txt");
-------Error-----------------------
use std::io::ErrorKind;
let greeting_file_result = File::open("hello.txt");
let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => match error.kind() {
            ErrorKind::NotFound => match File::create("hello.txt") {
                Ok(fc) => fc,
                Err(e) => panic!("Problem creating the file: {:?}", e)
            },
            other_error => {
                panic!("Problem opening the file: {:?}", error)
            }
        },
    };
let mut username_file = File::open("hello.txt")?;		#–∫–æ—Ä–æ—Ç–∫–∞—è —Ñ–æ—Ä–º–∞ "?", –¥–ª—è –æ–±—Ä–∞–±–æ—Ç–∫–∏ (—Ç–æ–ª—å–∫–æ –¥–ª—è Result)

----------Option<T>---------------------------------		# –º–µ—Ç–æ–¥—ã https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else
x.unwrap()
Some("car").unwrap_or("bike")
Some(4).unwrap_or_else(|| 2 * k)
-----------–ò—Ç–µ—Ä–∞—Ç–æ—Ä--------------------------------
v1.iter();						# —Å–æ–∑–¥–∞—ë—Ç –∏—Ç–µ—Ä–∞—Ç–æ—Ä –ø–æ –Ω–µ–∏–∑–º–µ–Ω—è–µ–º—ã–º —Å—Å—ã–ª–∫–∞–º
v1.into_iter()						# —Å—Ç–∞–Ω–æ–≤–∏—Ç—Å—è –≤–ª–∞–¥–µ–ª—å—Ü–µ–º v1 –∏ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –ø—Ä–∏–Ω–∞–¥–ª–µ–∂–∞—â–∏–µ –µ–º—É –∑–Ω–∞—á–µ–Ω–∏—è
v1.iter_mut()						# –µ—Å–ª–∏ –º—ã —Ö–æ—Ç–∏–º –ø–µ—Ä–µ–±–∏—Ä–∞—Ç—å –∏–∑–º–µ–Ω—è–µ–º—ã–µ —Å—Å—ã–ª–∫–∏
let v1_iter = v1.iter(); 
v1_iter.sum();
let v1: Vec<i32> = vec![1, 2, 3];
let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();
-------------–ú–Ω–æ–≥–æ–ø–æ—Ç–æ—á–Ω–æ—Å—Ç—å------------------------
use std::thread;
let handle = thread::spawn(|| { do smth });		# –∑–∞–ø—É—Å—Ç–∏—Ç—å –ø–∞—Ä–∞–ª–µ–ª–ª—å–Ω—ã–π –ø–æ—Ç–æ–∫
handle.join().unwrap();					# –¥–æ–∂–¥–∞—Ç—å—Å—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –ø–æ—Ç–æ–∫–∞
use std::sync::mpsc;					# –ø–µ—Ä–µ–¥–∞—á–∞ —Å–æ–æ–±—â–µ–Ω–∏–π –º–µ–∂–¥—É –ø–æ—Ç–æ–∫–∞–º–∏
let (tx, rx) = mpsc::channel();
-------------–®–∞–±–ª–æ–Ω—ã-------------------------------
let x = 1;
match x {
        1 => println!("one"),				# 1 | 2 => (), 1..=5 =>(),
        2 => println!("two"),
        _ => println!("anything"),			#.. => (),
    }