https://habr.com/ru/post/501442/  - Основные linux-команды для новичка
https://habr.com/ru/company/ruvds/blog/339820/ 20 приёмов работы в командной строке Linux, которые сэкономят уйму времени
--------------обновление--------------------------------------
sudo apt update				# обновление репозиториев ubuntu
sudo apt upgrade			# устанавливает самые новые версии всех пакетов доступные в репозиториях.
sudo apt full-upgrade			# кроме всего, что делает upgrade, здесь поддерживается умное разрешение зависимостей для новых версий пакетов. Конфликтующие пакеты могут быть удалены, а новые, дополнительные - установлены.
sudo apt update && sudo apt full-upgrade && sudo apt autoremove && sudo apt autoclean && sudo apt clean

command_1; command_2; command_3 	# Вызов нескольких команд в одной строке  для выполнения следующей команды не надо ждать завершения предыдущей
command_1 && command_2			# Этот разделитель позволяет гарантировать то, что следующая команда будет выполнена лишь в том случае, если предыдущая отработает успешно.
Ctrl + Q Разблокировка терминала после случайного нажатия Ctrl + S


man <command> 	# мануал к команде (напр. - $man man, $man ls, $man cd)
man -f ls	# краткое описание ls
netstat -tulpan				# порты, которые слушаютя
netstat -tulpan | grep 80		# отбор по цифре 80
chmod og+r $(find *.png)		# найти и изменить
-------------Директориии/папки-------------------------
mkdir <name>			#создание директории
mkdir <name1> <name2> <name3>	#Создать несколько папок
mkdir ~/test_directory/		#создать папку в домашней директории
mkdir /home/<user>/test_directory/ # то же	
sudo mkdir -p /home/ivan/compose/{nginx,postgres,code,dbdata} 	#-p — создание всех нижнеуровневых директорий, то есть директория compose (и /home, и ivan) будет создана при отсутствии,
								#{} — набор поддиректорий.
mv старое_имя новое_имя						#переименовать папку

rmdir <name>			#удаление директории
rmdir <name1> <name2> <name3>	#удалить несколько папок
rmdir /home/<user>/tesrdir	#удалить папку tesrdir по пути /home/user/

-------------Переход------------------
pwd					#показывает, в какой директории вы в данный момент находитесь
cd ключи папка назначения		#переход в требуемую директорию
cd visem				#переход в папку висем
cd ~/					#переход в домашнию директорию
cd ..					#переход назад
cd -					#Переход в последнюю рабочую директорию

--------------Команды для чтения файлов----------------------
cat					# $cat text_file команда (утилита), выводящая данные файла или последовательно несколько файлов, объединяя их в поток.
cat -n, --number 			#— выводит номера строк.
cat -b, --number-nonblank 		#— выводит строки с номерами, кроме пустых. Отменяет предыдущий ключ.
cat dmesg > ~/text_file			#перенаправить вывод из  файла dmesg не на терминал, а в какой-то другой файл.
cat dmesg syslog auth.log > ~/text_file #перенаправить вывод из двух файлов dmesg syslog auth.log (из примера выше) не на терминал, а в какой-то другой файл.
>					# Оператор > полностью заменяет данные в файле информацией.
>> 					# Оператор >> добавляет информацию в конец файла, не удаляя предыдущие данные.

head					# ($head ~/text_file) выводит первые строки с начала файла (default - 10 строк)
head -n, --lines			# ($head -n 5 ~/text_file) выводит строки, начиная от первой до той, которая указана после -n
head -c, --bytes			# ($head -с 5 ~/text_file) выводит данные побайтно, начиная с первого и заканчивая указанным после -c
tail					# утилита, работающая аналогично утилите head, но только с конца файла. Используются аналогичные ключи -n и -c
tail -f					# выводит новые строки с конца в режиме реального времени. Эта функция может использоваться при парсинге логов. в режиме онлайн, когда идёт отладка какого-либо сервера, а информацию требуется получать постоянно.

less					#команда для построчного чтения текста. В отличии от cat, не выводит на экран все данные, а хранит их в буфере, позволяя пролистывать страницы вперёд и назад.
	/pattern — поиск по шаблону вперёд (вниз по странице);
	?pattern — поиск по шаблону назад (вверх по странице);
------------------------Работа с файлами----------------------------------
# копирование файла
cp [ключи] исходный_файл конечный_файл или cp [ключи] исходный_файл конечный_каталог или cp [ключи] исходный_каталог конечный_каталог
-R, -r, --recursive копирует рекурсивно, т. е. все файлы и поддиректории в директориях. $ cp -r /var/log /home/user - перекопировать все файлы и вложенные директории в папку /home/user
-i, --interactive — запрашивает, требуется ли переписывать файл / -n, --no-clobber — не перезаписывать существующий файл /-p — сохраняет владельца, /-f, --force — если существующий конечный файл не может быть открыт для копирования, то удалит его и запишет новый./--remove-destination — в отличие от -f, сразу удалит существующий конечный файл без попытки его открыть и создаст новый.

# удаление файла
rm [ключи] файл или $rm [ключи] директория
-r, -R, --recursive — удаляет директории и содержимое в них./-i — выводит запрос на удаление каждого файла./-d, --dir — удаляет пустую директорию./-f, --force — игнорируются несуществующие файлы и аргументы. Не выдаёт запрос на подтверждение удаления.
rm /dir/*	# удалить все файлы в директории
rm -rf /dir/	# удаления файлов вместе с директориями 

# перемещение и переименование файла
mv [ключи] исходный_файл конечный_каталог (mv test_file /tmp/)
mv test_file /tmp/
-f, --force — не спрашивать разрешения на перезапись./-i, --interactive — спрашивать разрешения на перезапись существующих файлов./-n, --no-clobber — не перезаписывать существующие файлы.
-- — ключ, завершающий список ключей, используется для для файлов, начинающихся с -. Т.е. если у вас вдруг файл называется -file, то для того, чтобы его перенести, надо использовать синтаксис mv -- -file /tmp/.

touch имя_файла			# создать пустой файл
touch -d 20201201 имя_файла	# создания файла с определённой датой используется ключ -d и дата в формате ггггммдд:

--------------------Поиск-----------------------------------
find директория_поиска [ключи]			#(find / -name text_file) — поиск по имени во всех директориях системы /
find / -name "text_*" или find / -name "*.conf" #все файлы, название которых начинается с text_  или все файлы, которые заканчиваются на .conf
find / -name "te*" -a -name "*le"		#-a — логическое «И». «И» можно использовать, когда известны начало и конец файла. / -o — логическое «ИЛИ».
find . ! -name "*text*"				# ! — логический оператор для отрицания. будут найдены все файлы, кроме тех, в названии которых содержится text.
Точка означает текущую директорию
find . -mtime +3 				# все файлы, которые изменялись более трёх дней назад 
-type						#f — файл/d — каталог/l — ссылка/s — сокет/p — канал
-exec 						#который позволяет выполнять команду над найденными файлами
find . -newermt "sep 21" -exec rm {} \;		#будут удалены все файлы, которые были изменены не раньше 21 сентября. Либо, если сказать иначе, 21 сентября и позже
{} — нужно для указания вывода строки списка файлов, которая была найдена по команде поиска.
Командная строка должна завершаться последовательностью символов \; Он указывает на конец exec.

grep 						#(фильтр) это утилита, позволяющая проводить поиск строк. С её помощью ищутся конкретные слова в файле, также этой команде можно передать любой вывод для поиска, что упрощает работу
grep [ключи] строка путь_к_файлам		# -l, --files-with-matches — выводит имя каждого файла, в котором совпадают данные./-i, --ignore-case — игнорирование регистра./-r, --recursive — рекурсивный поиск./-v — инвертированный вывод.
cat /var/log/auth.log |grep user		#(grep user /var/log/auth.log) из файла логов вывести строки, содержащие слово user.
grep -rl "Port 22" /etc/			#Где ключ -r отвечает за то, что это будет рекурсивный поиск, а ключ -l за то, чтобы выводились не просто строки, а пути к файлам, где эти строки находятся. Т. к. в Port 22 есть пробел, то фразу надо брать в кавычки, двойные или одинарные, иначе команда не сработает, и он будет пытаться найти строку Port в файле 22, которого не существует.

ls [ключи] [директория]				#(ls /var/log) посмотреть, что находится в директории /var/log
ls 						# просмотр содержимого в текущей директории /-a, --all — выдавать все файлы в каталогах, включая скрытые файлы, начинающиеся с точки.
ls -l или ll или ls -la				# Вывести содержимое директорий с отображением прав на файлы.

-----------------Доступ------------------------------------
id 						# получение информации о пользователе
cat /etc/passwd					# Прочесть файл с информацией о пользователях.
su -						# залогиниться под root (После правильного ввода пароля значок $ сменится на #, что будет означать — у вас root-привилегии.)
sudo						# используется, чтобы зайти временно под суперпользователя и выполнить команду от имени root
sudo cat /home/worker/.bash_history		# пример, при условии, что пользователь добавлен в группу sudo и ввёл пароль, доступ будет разрешён.
su user2					# залогиниться под user2
exit или Ctrl-D
-----------------------Пользователь----------------
Чтобы это сделать, вы должны обладать правами root, иначе вам не будет хватать прав внести изменения в файл /etc/passwd. Поэтому не забудьте применить при создании пользователя команду sudo или войдите как пользователь root с помощью команды sudo su.
useradd ключи аргументы					# созданиe пользователя в Linux 
sudo useradd user1  или useradd user1			# Где user-1 — это логин пользователя - Но при этом ваш пользователь должен быть добавлен в группу sudo, потому что после этой команды система запросит пароль для вашей учетной записи:
sudo useradd -p 123qwerty user1				# Где после ключа -p (--password) указывается сам пароль.
sudo useradd -p 123qwerty -G sudo user1			# (-G, --groups) Для добавления пользователя в группу (sudo)
sudo useradd -p 123qwerty -G sudo -s /bin/bash user1	# По умолчанию для пользователя назначается оболочка sh, для назначения другой оболочки используется ключ -s, s--shell. Для указания оболочки используется полный путь к ней:
Рассмотрев основные принципы создания пользователей, рассмотрим список ключей ниже:
-d, --home-dir — для создания домашней директории пользователя. Если не указывать этот ключ, то будет создана домашняя директория в /home. Если его указать, то можно задать другое место для домашней директории, например, в директории /var. Может пригодиться, когда будете создавать пользователей для FTP.
-m, --create-home — создаёт домашнюю директорию в /home. 
-M, --no-create-home — не создает домашнюю директорию для пользователя.
-u, --uid — требуется для того, что бы вручную задать uid пользователя.
-r, -system — создаёт системного пользователя.
-h, -help — выводит справку по useradd.
sudo useradd -m -G old_group -s /bin/rbash new_user  	# example Добавьте пользователя с созданной домашней директорией, что бы у него была командная оболочка rbash, назывался он new_user и входил в группу old_group. Напишите команду полностью:

passwd ключ аргумент					# применяется для смены пароля пользователя
Ниже приведён список ключей команды работы с паролями:
-d, --delete— удалить пароль пользователя (сделать его пустым). Это быстрый способ заблокировать пароль учётной записи. Это делает указанную учётную запись беспарольной.
-i, --inactive <кол_во_дней> — этот параметр используется для блокировки учётной записи по прошествии заданного числа дней после устаревания пароля. То есть, если пароль устарел и прошло более указанных <кол_во_дней>, то пользователь больше не сможет использовать данную учётную запись.
-m, --mindays <кол_во_дней> — задать минимальное количество дней между сменой пароля. Нулевое значение этого поля указывает на то, что пользователь может менять свой пароль, когда захочет.
-w, --wardays <кол_во_дней> — установить число дней выдачи предупреждения, перед тем как потребуется смена пароля. В параметре <кол_во_дней> указывается число дней перед тем, как пароль устареет, в течение которых пользователю будут напоминать, что пароль скоро устареет.
-x, --maxdays <кол_во_дней> — установить максимальное количество дней, в течение которых пароль остаётся рабочим. После <кол_во_дней> пароль нужно изменить.
-a, --all — применяется только вместе с -S для вывода статуса всех пользователей.
-d, --delete — удаляет пароль пользователя, оставляя его пустым. Этот ключ можно применить, чтобы заблокировать пользователя, так как без пароля он и не зайдёт в систему, и не сможет зайти в sudo.
-e, --expire — делает текущий пароль пользователя устаревшим. При следующей попытке пользователя зайти в систему ему придётся сменить пароль.
-h, --help — выводит на экран краткую справку.
Стоит обратить внимание на то, что применять её можно только в режиме суперпользователя, либо применять без ключей и аргументов, чтобы сменить пароль пользователю, под которым находитесь.
passwd -S worker или passwd worker			#смены пароля другому пользователю (ключ -S, --status)
chpasswd						# массовая смена паролей - завершить ввод Ctrl+D - Сначала вы вводите команду, и курсор переместится на поле вниз. После этого потребуется ввести логин пользователя, а потом, через двоеточие, — пароль.
cat polzovateli_i_paroli |  chpasswd			# тоже через записанный файл, формат user1:password1 нов строка  user2:password2

usermod ключи логин					# для изменения учётной записи пользователя, если пользователь уже существует. Применяется с правами суперпользователя или sudo
usermod -aG sudo user1					# для добавления в группу sudo пользователя user1 (Ключи -a, --append и -G, --groups используются только совместно, для добавления пользователя в новую группу. Если надо добавить в несколько групп, то их можно перечислять через запятую.)

userdel [ключи] логин					# Для удаления пользователя из системы
userdel user1						# 
userdel -r user1					# удалить пользователя вместе с домашней директорией, надо использовать ключ  -r, --remove:
userdel -rf user1					# А если случилось такое, что пользователь до сих пор активен в системе, то для его удаления нужно применить ключ -f, --force:

users							# посмотреть, какие пользователи в данный момент активны в системе
chfn 		chfn ключ логин				# команда изменения информации о пользователе:
-f — полное имя,
-r — номер комнаты,
-w — рабочий телефон,
-h — домашний телефон,
-o — комментарии,
-chage — команда для смены срока действия пароля.

chsh [-s путь к оболочке] логин 			# (change sh) команда для смены командной оболочки
find / -user имя_пользователя				# вывести все файлы, принадлежащие пользователю

------------------------Группы----------------------------
/etc/group						# Весь список групп хранится в /etc/group.
groupadd ключ имя_группы				# создавать группу (пр., groupadd group0)
tail -n 1 /etc/group					# посмотреть вновь созданную группу
usermod -aG group0 user1				# обавить пользователя user1 в созданную группу group0
cat /etc/group | grep user1				# Чтобы узнать, в каких группах состоит пользователь, можно применить команду grep c поиском по файлу /etc/group, предварительно выведя файл через cat. Для примера возьмём пользователя
-f, --force — этот ключ заставляет команду просто завершиться с успешным статусом. Если вы при создании группы укажете, к примеру, уже существующий gid, то он проигнорирует его и создаст новый, как в случае без указания -g. Может быть удобно, если у вас в системе уже очень много групп и не получится подобрать подходящий идентификатор группы.
-g,  --gid — создаёт группу с определённым идентификатором gid. Без этого ключа будет создана группа с идентификатором, который станет следующим по порядку, после последней существующей группы. Напомним, что он должен быть от 1000 до 999999999.
-h,  --help — показывает инструкцию.
-o,  --non-unique — позволяет создать группу с не уникальным gid.
-r,  --system — создаёт системную группу (по аналогии с системным пользователем).

groupmod ключи имя_группы				#-g — меняет gid группы / -n — смена имени группы. Например, требуется изменить имя группы group0 на group1. команда для изменения группы. Используется для смены gid или имени группы.
groupdel имя_группы					# используется для удаления групп
groups							# покажет вам список групп, в которых вы состоите.
chgrp							# Смена группы.


mkdir		#создать папку
$ mv старое_имя новое_имя	#переименовать папку
sudo chmod 777 db_django	#права удалить папку
sudo rm -r db_django/

-----------------------------Изменение прав--------------------
chmod ключи аргументы		#  команда для изменения прав доступа к файлам и каталогам. Аргументами в данном случае будут являться файлы и/или директории.
chmod o+wrx dir1		# параметр букву o (other) — мы поставили +, что значит «Добавить», прописали wrx, что значит «Добавить права на запись, чтение и выполнение».
o+wrx для других, g+wrx группы, a+wrx all-для всех, +wrx тоже,для всех 
владельца файла (u);
других пользователей, входящих в группу владельца (g);
всех прочих пользователей (o);
chmod 757 dir1			# то же 
-c, --changes — используя этот ключ, вы увидите подробное описание, для каких файлов и директорий будут меняться права. Его лучше использовать вместе с ключом -R.
-R, --recursive — рекурсивное изменение прав доступа для каталогов и их содержимого.
chmod -R -xrw dir1		# Чтобы изменить на них права массово, то есть не применяя отдельно команду к каждому файлу, а также к каждой вложенной директории, если бы они были, надо использовать ключ рекурсии. К примеру, мы хотим сделать так, чтобы для всех файлов в директории и для самой директории ни у кого не было прав, только у root
chmod -R -xrw dir1/*		# изменения затронут всё внутри директории, но не затронут саму директорию.
chmod og+r $(find *.png)	# добавить права(группы и др.пользователи) на чтение ко всем .png файлам в текущей папке

chown [ключ] пользователь[:группа] файл_или_директория		#  изменяет владельца и группу файла
chown user2:group1  /tmp/dir1					# сменить и владельца, и группу
chown user2 /tmp/dir1						# чтобы у dir1 был владельцем user2, а не root
-c, --changes — описывает действия для каждого файла, владелец или группа которого изменена.
-f, --silent, --quiet — не выдавать сообщения об ошибках для файлов, чей владелец не может быть изменён.
-v, --verbose — подробное описание действия (или отсутствия действия) для каждого файла. То есть отличается от -c тем, что по-любому скажет, был изменён владелец и группа или нет.
-R, --recuirsive — рекурсивное изменение владельца каталогов и их содержимого. Работает так же, как аналогичный ключ из прошлой команды, то есть изменяет массово.

Три варианта записи прав пользователя
двоичная	восьмеричная	символьная	права на файл		права на каталог
000		0		---		нет			нет
001		1		--x		выполнение		чтение свойств файлов
010		2		-w-		запись			нет
011		3		-wx		запись и выполнение	всё, кроме получения имени файлов
100		4		r--		чтение			чтение имён файлов
101		5		r-x		чтение и выполнение	доступ на чтение файлов/их свойств
110		6		rw-		чтение и запись		чтение имён файлов
111		7		rwx		все права		все права

----------------------------Время и даты-----------------------
date				# Демонстрация и изменение времени.
-d, --date=СТРОКА — показывает не текущее время, а время, описанное заданной СТРОКОЙ. Может пригодиться при написании скриптов на bash. Например, date --date='Thu 20 Nov 2020 10:27:59 PM MSK' или date -d 202001012.
-f, --file=ФАЙЛ — соответствует применению --date для каждой строки ФАЙЛА. Опять же, может пригодиться для использования на bash.
-r, --reference=ФАЙЛ — показывает время последнего изменения ФАЙЛА.
-s, --set — устанавливает время, описанное после ключа. Но эту функцию лучше не использовать, для этого существуют другие, более действенные команды.
date -s 030117562020		# Здесь мы установили время и дату на 3 января 2020 года на 17 часов 56 минут.
timedatectl			# Для установки времени при отсутствии синхронизации с NTP-сервером

timedatectl [ключи] [команды] [аргументы] 
status	Команда по умолчанию. С ней показывает то же самое, что и просто timedatectl.
show	Показывает настройки системных часов, RTC, активна ли синхронизация сетевого времени. Если команда не указывается, то она подразумевается по умолчанию.
set-time	Установка времени. Время вводится после команды в формате "2012-10-30 18:17:16".
set-timezone	Устанавливает нужную временную зону (из прошлого примера).
list-timezones	Показывает все доступные временные зоны (как в прошлом примере).
set-local-rtc	Установка RTC. Вводится число из двоичной системы счисления: 0 — если система настроена на поддержание всемирного времени, и 1 — если требуется поддерживать системой локальное время. Либо yes, либо no.
set-ntp	Из примера, указывает, активна ли синхронизация по сети, протоколу NTP. Вводятся значения off и on.
timesync-status	Показывает дополнительную системную информацию, например, какой установлен сервер синхронизации времени, его адрес, как часто с ним происходит синхронизация и прочее.
show-timesync	Показывает то же, что и прошлая команда, но в машинном формате.
ntp-servers	Устанавливает другие сервера для интерфейса синхронизации времени, какие вы укажете.
revert	Восстанавливает сервера обратно, если они были установлены предыдущей командой (ntp-servers).
--monitor — если вызывается timesync-status с этим ключом, то он не просто выведет его на экран терминала один раз, а будет постоянно мониторить. Выйти из этого режима можно с помощью Сtrl+С.
-a, --all — показывает дополнительную информацию, где её можно вывести.
-h, --help — справка.

hwclock 					# Вывести системное время (Изменение аппаратного времени сервера.)
hwclock [ключи]  [аргументы] 			# утилита для управления аппаратными часами.
hwclock --set --date="2011-01-25 08:55:01"	# Устанавливает конкретное значение аппаратного времени:
-r, --show — показывает аппаратное время.
--set — устанавливает системное время в соответствии с данными после ключа --date, как в примере.
-s, --hctosys — устанавливает системное время в соответствии с аппаратными часами.
-w, --systohc — устанавливает аппаратное время в соответствии с системным временем.
-u, --utc — устанавливает аппаратные часы в UTC.
-l, --localtime — устанавливает аппаратные часы в локальное время.
-h, --help — краткая справка.

times



------------------------редактор vi------------------------
vi filename			# открыть в vi файл filename (или создать)
:h				# справка
i				# перейдёт в режим ввода текста
dd				# Вырезать строку
p				# Вставить
u				# Отменить последнее действие (можно многократно)
Escape				# Выйти из режима ввода текста
:				# вход в коммандный режим
:e!				# Перезагрузить текущий файл
:w				# сохранения текста 
:q				# выход из редактора
:wq				# выход из редактора и сохранение (Команда ZZ аналогична :wq)
:q! или ZQ			# выход из редактора без сохранения
---------------------редактор nano---------------------------
nano filename
Сtrl+x — выход.
Если предварительно файл был изменён, он предложит его сохранить. Для этого надо будет согласиться (откроется поле для ввода, он предложит ввести y — yes, n — no или с — cancel), а потом предложит изменить имя файла или оставить его таким же.
Ctrl+o — сохранение файла.
Также предложит ввести новое имя для сохранения или оставить старое. Если вводить новое имя, то будет создан новый файл в той же директории, где происходило редактирование.
Ctrl+k — вырезать текст.
Вырезает построчно.
Ctrl+u — вставить вырезанный текст.
---------------------------------------------------------------