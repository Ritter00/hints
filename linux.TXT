https://habr.com/ru/post/501442/  - Основные linux-команды для новичка
https://habr.com/ru/company/ruvds/blog/339820/ 20 приёмов работы в командной строке Linux, которые сэкономят уйму времени
command_1; command_2; command_3 	# Вызов нескольких команд в одной строке  для выполнения следующей команды не надо ждать завершения предыдущей
command_1 && command_2			# Этот разделитель позволяет гарантировать то, что следующая команда будет выполнена лишь в том случае, если предыдущая отработает успешно.
Ctrl + Q Разблокировка терминала после случайного нажатия Ctrl + S


man <command> 	# мануал к команде (напр. - $man man, $man ls, $man cd)
man -f ls	# краткое описание ls

-------------Директориии/папки-------------------------
mkdir <name>			#создание директории
mkdir <name1> <name2> <name3>	#Создать несколько папок
mkdir ~/test_directory/		#создать папку в домашней директории
mkdir /home/user/test_directory/ # то же	

rmdir <name>			#удаление директории
rmdir <name1> <name2> <name3>	#удалить несколько папок
rmdir /home/user/tesrdir	#удалить папку tesrdir по пути /home/user/

-------------Переход------------------
pwd					#показывает, в какой директории вы в данный момент находитесь
cd ключи папка назначения		#переход в требуемую директорию
cd visem				#переход в папку висем
cd ~/					#переход в домашнию директорию
cd ..					#переход назад
cd -					#Переход в последнюю рабочую директорию

--------------Команды для чтения файлов----------------------
cat					# $cat text_file команда (утилита), выводящая данные файла или последовательно несколько файлов, объединяя их в поток.
cat -n, --number 			#— выводит номера строк.
cat -b, --number-nonblank 		#— выводит строки с номерами, кроме пустых. Отменяет предыдущий ключ.
cat dmesg > ~/text_file			#перенаправить вывод из  файла dmesg не на терминал, а в какой-то другой файл.
cat dmesg syslog auth.log > ~/text_file #перенаправить вывод из двух файлов dmesg syslog auth.log (из примера выше) не на терминал, а в какой-то другой файл.
>					# Оператор > полностью заменяет данные в файле информацией.
>> 					# Оператор >> добавляет информацию в конец файла, не удаляя предыдущие данные.

head					# ($head ~/text_file) выводит первые строки с начала файла (default - 10 строк)
head -n, --lines			# ($head -n 5 ~/text_file) выводит строки, начиная от первой до той, которая указана после -n
head -c, --bytes			# ($head -с 5 ~/text_file) выводит данные побайтно, начиная с первого и заканчивая указанным после -c
tail					# утилита, работающая аналогично утилите head, но только с конца файла. Используются аналогичные ключи -n и -c
tail -f					# выводит новые строки с конца в режиме реального времени. Эта функция может использоваться при парсинге логов. в режиме онлайн, когда идёт отладка какого-либо сервера, а информацию требуется получать постоянно.

less					#команда для построчного чтения текста. В отличии от cat, не выводит на экран все данные, а хранит их в буфере, позволяя пролистывать страницы вперёд и назад.
	/pattern — поиск по шаблону вперёд (вниз по странице);
	?pattern — поиск по шаблону назад (вверх по странице);
------------------------Работа с файлами----------------------------------
# копирование файла
cp [ключи] исходный_файл конечный_файл или cp [ключи] исходный_файл конечный_каталог или cp [ключи] исходный_каталог конечный_каталог
-R, -r, --recursive копирует рекурсивно, т. е. все файлы и поддиректории в директориях. $ cp -r /var/log /home/user - перекопировать все файлы и вложенные директории в папку /home/user
-i, --interactive — запрашивает, требуется ли переписывать файл / -n, --no-clobber — не перезаписывать существующий файл /-p — сохраняет владельца, /-f, --force — если существующий конечный файл не может быть открыт для копирования, то удалит его и запишет новый./--remove-destination — в отличие от -f, сразу удалит существующий конечный файл без попытки его открыть и создаст новый.

# удаление файла
rm [ключи] файл или $rm [ключи] директория
-r, -R, --recursive — удаляет директории и содержимое в них./-i — выводит запрос на удаление каждого файла./-d, --dir — удаляет пустую директорию./-f, --force — игнорируются несуществующие файлы и аргументы. Не выдаёт запрос на подтверждение удаления.
rm /dir/*	# удалить все файлы в директории
rm -rf /dir/	# удаления файлов вместе с директориями 

# перемещение и переименование файла
mv [ключи] исходный_файл конечный_каталог (mv test_file /tmp/)
mv test_file /tmp/
-f, --force — не спрашивать разрешения на перезапись./-i, --interactive — спрашивать разрешения на перезапись существующих файлов./-n, --no-clobber — не перезаписывать существующие файлы.
-- — ключ, завершающий список ключей, используется для для файлов, начинающихся с -. Т.е. если у вас вдруг файл называется -file, то для того, чтобы его перенести, надо использовать синтаксис mv -- -file /tmp/.

touch имя_файла			# создать пустой файл
touch -d 20201201 имя_файла	# создания файла с определённой датой используется ключ -d и дата в формате ггггммдд:

--------------------Поиск-----------------------------------
find директория_поиска [ключи]			#(find / -name text_file) — поиск по имени во всех директориях системы /
find / -name "text_*" или find / -name "*.conf" #все файлы, название которых начинается с text_  или все файлы, которые заканчиваются на .conf
find / -name "te*" -a -name "*le"		#-a — логическое «И». «И» можно использовать, когда известны начало и конец файла. / -o — логическое «ИЛИ».
find . ! -name "*text*"				# ! — логический оператор для отрицания. будут найдены все файлы, кроме тех, в названии которых содержится text.
Точка означает текущую директорию
find . -mtime +3 				# все файлы, которые изменялись более трёх дней назад 
-type						#f — файл/d — каталог/l — ссылка/s — сокет/p — канал
-exec 						#который позволяет выполнять команду над найденными файлами
find . -newermt "sep 21" -exec rm {} \;		#будут удалены все файлы, которые были изменены не раньше 21 сентября. Либо, если сказать иначе, 21 сентября и позже
{} — нужно для указания вывода строки списка файлов, которая была найдена по команде поиска.
Командная строка должна завершаться последовательностью символов \; Он указывает на конец exec.

grep 						#(фильтр) это утилита, позволяющая проводить поиск строк. С её помощью ищутся конкретные слова в файле, также этой команде можно передать любой вывод для поиска, что упрощает работу
grep [ключи] строка путь_к_файлам		# -l, --files-with-matches — выводит имя каждого файла, в котором совпадают данные./-i, --ignore-case — игнорирование регистра./-r, --recursive — рекурсивный поиск./-v — инвертированный вывод.
cat /var/log/auth.log |grep user		#(grep user /var/log/auth.log) из файла логов вывести строки, содержащие слово user.
grep -rl "Port 22" /etc/			#Где ключ -r отвечает за то, что это будет рекурсивный поиск, а ключ -l за то, чтобы выводились не просто строки, а пути к файлам, где эти строки находятся. Т. к. в Port 22 есть пробел, то фразу надо брать в кавычки, двойные или одинарные, иначе команда не сработает, и он будет пытаться найти строку Port в файле 22, которого не существует.

ls [ключи] [директория]				#(ls /var/log) посмотреть, что находится в директории /var/log
ls 						# просмотр содержимого в текущей директории /-a, --all — выдавать все файлы в каталогах, включая скрытые файлы, начинающиеся с точки.
ls -l , ll					# для вывода содержимого директорий



mkdir		#создать папку
$ mv старое_имя новое_имя	#переименовать папку
sudo chmod 777 db_django	#права удалить папку
sudo rm -r db_django/

------------------------редактор vi------------------------
vi filename			# открыть в vi файл filename (или создать)
:h				# справка
i				# перейдёт в режим ввода текста
dd				# Вырезать строку
p				# Вставить
u				# Отменить последнее действие (можно многократно)
Escape				# Выйти из режима ввода текста
:				# вход в коммандный режим
:e!				# Перезагрузить текущий файл
:w				# сохранения текста 
:q				# выход из редактора
:wq				# выход из редактора и сохранение (Команда ZZ аналогична :wq)
:q! или ZQ			# выход из редактора без сохранения
---------------------редактор nano---------------------------
nano filename
Сtrl+x — выход.
Если предварительно файл был изменён, он предложит его сохранить. Для этого надо будет согласиться (откроется поле для ввода, он предложит ввести y — yes, n — no или с — cancel), а потом предложит изменить имя файла или оставить его таким же.
Ctrl+o — сохранение файла.
Также предложит ввести новое имя для сохранения или оставить старое. Если вводить новое имя, то будет создан новый файл в той же директории, где происходило редактирование.
Ctrl+k — вырезать текст.
Вырезает построчно.
Ctrl+u — вставить вырезанный текст.
---------------------------------------------------------------